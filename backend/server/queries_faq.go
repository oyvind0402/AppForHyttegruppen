package server

import (
	"bachelorprosjekt/backend/data"
	"context"
	"encoding/json"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

// Retrieve one faq by ID (receives string; returns FAQ(ID of type primitive.ObjectId))
func (r repo) GetOneFAQ(ctx *gin.Context) {
	// Retrieve parameter ID
	faqId := new(string)
	if err := ctx.BindJSON(faqId); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Convert id string to ObjectId
	objectId, err := primitive.ObjectIDFromHex(*faqId)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Select faq from database
	collection := r.noSqlDb.Database("hyttegruppen").Collection("faq")
	res := collection.FindOne(
		context.Background(),
		bson.D{primitive.E{Key: "_id", Value: primitive.ObjectID(objectId)}},
	)
	if res.Err() == mongo.ErrNoDocuments {
		ctx.AbortWithStatusJSON(http.StatusNotFound, gin.H{"err": res.Err().Error()})
		return
	}
	if res.Err() != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": res.Err().Error()})
		return
	}

	// Populate FAQ array that will be returned
	var faq data.FAQ[primitive.ObjectID]
	if err := res.Decode(&faq); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Return success and one faq
	ctx.JSON(http.StatusOK, faq)
}

// Retrieve all faqs in database (receives NOTHING; returns []FAQ (ID of type primitive.ObjectId))
func (r repo) GetAllFAQs(ctx *gin.Context) {
	// Select faq from database
	collection := r.noSqlDb.Database("hyttegruppen").Collection("faq")
	cursor, err := collection.Find(context.Background(), bson.D{})
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Create FAQ array
	var faqs []data.FAQ[primitive.ObjectID]
	err = cursor.All(context.Background(), &faqs)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Return success and FAQ array
	ctx.JSON(200, faqs)
}

// Post one faq (receives FAQ: FAQ (id of type String); returns InsertedId: data.FAQ (id of type primitive.ObjectID))
func (r repo) PostFAQ(ctx *gin.Context) {
	// Retrieve FAQ
	faq := new(data.FAQ[string])
	err := ctx.BindJSON(faq)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Do not accept FAQs with id
	if faq.Id != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": "id for FAQ was sent, but id is autogenerated"})
		return
	}

	// Add faq to database
	collection := r.noSqlDb.Database("hyttegruppen").Collection("faq")
	res, err := collection.InsertOne(
		context.Background(),
		faq,
	)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Return success and ID of added faq
	ctx.JSON(200, res.InsertedID)
}

// Update one faq (receives faq: FAQ (ID of type string); returns preUpdateFaq: FAQ (ID of type primitive.ObjectID))
func (r repo) UpdateFAQ(ctx *gin.Context) {
	// Retrieve ID parameter
	newFaq := new(data.FAQ[string])
	if err := ctx.BindJSON(newFaq); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Convert id string to ObjectId
	objectId, err := primitive.ObjectIDFromHex(*newFaq.Id)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Create id-less object for updating (_id must not be updated)
	var idlessFaq map[string]interface{}
	inrec, _ := json.Marshal(newFaq)
	json.Unmarshal(inrec, &idlessFaq)

	// Update on database
	collection := r.noSqlDb.Database("hyttegruppen").Collection("faq")
	res := collection.FindOneAndReplace(context.Background(), bson.D{primitive.E{Key: "_id", Value: objectId}}, idlessFaq)
	if res.Err() == mongo.ErrNoDocuments {
		ctx.AbortWithStatusJSON(http.StatusNotFound, gin.H{"err": res.Err().Error()})
		return
	}
	if res.Err() != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": res.Err().Error()})
		return
	}

	// Retrieve response value
	var preUpdateDoc data.FAQ[primitive.ObjectID]
	if err := res.Decode(&preUpdateDoc); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Return the document as it was BEFORE deletion
	ctx.JSON(200, preUpdateDoc)
}

// Delete one faq with specified ID (receives faqId: string; returns deletedFaq: FAQ)
func (r repo) DeleteFAQ(ctx *gin.Context) {
	// Retrieve ID parameter
	faqId := new(string)
	if err := ctx.BindJSON(faqId); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Convert id string to ObjectId
	objectId, err := primitive.ObjectIDFromHex(*faqId)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Delete from database
	collection := r.noSqlDb.Database("hyttegruppen").Collection("faq")
	res := collection.FindOneAndDelete(context.Background(), bson.D{primitive.E{Key: "_id", Value: objectId}})
	if res.Err() == mongo.ErrNoDocuments {
		ctx.AbortWithStatusJSON(http.StatusNotFound, gin.H{"err": res.Err().Error()})
		return
	}
	if res.Err() != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": res.Err().Error()})
		return
	}

	// Retrieve response value
	var deletedDoc data.FAQ[primitive.ObjectID]
	if err := res.Decode(&deletedDoc); err != nil {
		ctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
		return
	}

	// Return the document as it was BEFORE deletion
	ctx.JSON(200, deletedDoc)
}
